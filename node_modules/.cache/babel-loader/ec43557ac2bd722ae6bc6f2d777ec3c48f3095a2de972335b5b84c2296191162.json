{"ast":null,"code":"var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"kind\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.indexOf(n) >= 0) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { useAnalytics } from '../../contexts';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { useForwardedRef } from '../../utils';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\nvar defaultThreshold = 0.5;\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n  if (match) {\n    var arrayName = match[1],\n      indexOfArray = match[2],\n      arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n  return undefined;\n};\nvar getValueAt = function getValueAt(valueObject, pathArg) {\n  if (valueObject === undefined) return undefined;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) return valueObject[path];\n  return getValueAt(valueObject[path.shift()], path);\n};\nvar setValueAt = function setValueAt(valueObject, pathArg, value) {\n  var object = valueObject;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) object[path] = value;else {\n    var key = path.shift();\n    if (!object[key]) object[key] = {};\n    setValueAt(object[key], path, value);\n  }\n};\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var _value$arrayName;\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n  return getValueAt(value, name);\n};\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    setValueAt(nextValue, name, componentValue);\n  }\n  return nextValue;\n};\nvar validateCharacterCount = function validateCharacterCount(format, rule, value) {\n  var max = rule.max,\n    threshold = rule.threshold;\n  var getMessage = function getMessage() {\n    var charactersRemaining = function charactersRemaining(plural) {\n      return {\n        id: \"formField.maxCharacters.remaining.\" + (plural ? 'plural' : 'singular'),\n        values: {\n          number: max - value.length\n        }\n      };\n    };\n    var charactersOverLimit = function charactersOverLimit(plural) {\n      return {\n        id: \"formField.maxCharacters.overLimit.\" + (plural ? 'plural' : 'singular'),\n        values: {\n          number: value.length - max\n        }\n      };\n    };\n    if (max - value.length >= 0) {\n      return format(charactersRemaining(max - value.length > 1));\n    }\n    return format(charactersOverLimit(value.length - max > 1));\n  };\n  return value.length / max > (threshold != null ? threshold : defaultThreshold) ? {\n    status: max - value.length >= 0 ? 'info' : 'error',\n    message: getMessage()\n  } : undefined;\n};\n\n// Apply validation rule to field value and send correct messaging.\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  } else if (rule.max) {\n    result = validateCharacterCount(format, rule, fieldValue);\n  }\n  return result;\n};\n\n// Validates particular key in formValue\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n    if (required && (\n    // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n    return validationResult;\n  };\n};\n\n// Validates all keys in formValue\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n      _ref$ = _ref[1],\n      field = _ref$.field,\n      input = _ref$.input,\n      validateOn = _ref$.validateOn;\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n    if (!validateOn) return;\n    var result;\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    }\n    // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\nvar isInstantValidate = function isInstantValidate(validateOn) {\n  return ['blur', 'change'].includes(validateOn);\n};\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n    _ref2$errors = _ref2.errors,\n    errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n    _ref2$infos = _ref2.infos,\n    infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n    messages = _ref2.messages,\n    kind = _ref2.kind,\n    onChange = _ref2.onChange,\n    _onReset = _ref2.onReset,\n    _onSubmit = _ref2.onSubmit,\n    onValidate = _ref2.onValidate,\n    _ref2$validate = _ref2.validate,\n    validateOnProp = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n    valueProp = _ref2.value,\n    rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n  var formRef = useForwardedRef(ref);\n  var _useContext = useContext(MessageContext),\n    format = _useContext.format;\n  var _useState = useState(valueProp || defaultValue),\n    valueState = _useState[0],\n    setValueState = _useState[1];\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n  var _useState2 = useState(defaultTouched),\n    touched = _useState2[0],\n    setTouched = _useState2[1];\n  var _useState3 = useState(validateOnProp),\n    validateOn = _useState3[0],\n    setValidateOn = _useState3[1];\n  var _useState4 = useState({\n      errors: errorsProp,\n      infos: infosProp\n    }),\n    validationResults = _useState4[0],\n    setValidationResults = _useState4[1];\n  // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n  var validationResultsRef = useRef({});\n  // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n  var _useState5 = useState('unmounted'),\n    mounted = _useState5[0],\n    setMounted = _useState5[1];\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]);\n  // `pendingValidation` is the name of the FormField awaiting validation.\n  var _useState6 = useState(undefined),\n    pendingValidation = _useState6[0],\n    setPendingValidation = _useState6[1];\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var analyticsRef = useRef({\n    start: new Date(),\n    errors: {}\n  });\n  var sendAnalytics = useAnalytics();\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]);\n\n  // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n  var updateAnalytics = function updateAnalytics() {\n    var _validationResultsRef;\n    var errorFields = Object.keys((_validationResultsRef = validationResultsRef.current) == null ? void 0 : _validationResultsRef.errors);\n    var errorCounts = analyticsRef.current.errors;\n    if (errorFields.length > 0) {\n      errorFields.forEach(function (key) {\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n    }\n  };\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n      validatedErrors = _validateForm[0],\n      validatedInfos = _validateForm[1];\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n      // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      updateAnalytics();\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]);\n\n  // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n    if (mounted !== 'mounted' && (isInstantValidate(validateOn) || validationRules.some(function (_ref3) {\n      var v = _ref3[1];\n      return isInstantValidate(v.validateOn);\n    })) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref4) {\n        var n = _ref4[0],\n          v = _ref4[1];\n        return getFieldValue(n, value) && v.validateOn;\n      })\n      // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref5) {\n        var n = _ref5[0];\n        return !(Array.isArray(getFieldValue(n, value)) && getFieldValue(n, value).length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]);\n\n  // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && (isInstantValidate(validateOn) || validationRules.some(function (_ref6) {\n        var v = _ref6[1];\n        return isInstantValidate(v.validateOn);\n      }))) {\n        applyValidationRules(validationRules.filter(function (_ref7) {\n          var n = _ref7[0],\n            v = _ref7[1];\n          return (touched[n] || pendingValidation.includes(n)) && v.validateOn;\n        }));\n        setPendingValidation(undefined);\n      }\n      // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]);\n\n  // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n  useEffect(function () {\n    var _validationResultsRef2;\n    var validationRules = Object.entries(validationRulesRef.current);\n    if ((_validationResultsRef2 = validationResultsRef.current) != null && _validationResultsRef2.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref8) {\n        var n = _ref8[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]);\n  useEffect(function () {\n    var element = formRef.current;\n    analyticsRef.current = {\n      start: new Date(),\n      errors: {}\n    };\n    sendAnalytics({\n      type: 'formOpen',\n      element: element\n    });\n    return function () {\n      if (!analyticsRef.current.submitted) {\n        sendAnalytics({\n          type: 'formClose',\n          element: element,\n          errors: analyticsRef.current.errors,\n          elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n        });\n      }\n    };\n  }, [sendAnalytics, formRef]);\n\n  // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref9) {\n      var name = _ref9.name,\n        componentValue = _ref9.value,\n        initialValue = _ref9.initialValue,\n        validateArg = _ref9.validate;\n      var _useState7 = useState(initialValue),\n        inputValue = _useState7[0],\n        setInputValue = _useState7[1];\n      var formValue = name ? getFieldValue(name, value) : undefined;\n      // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n      var keyCreated = useRef(false);\n\n      // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n      useEffect(function () {\n        if (name &&\n        // we have somewhere to put this\n        componentValue !== undefined && (\n        // input driving\n        Array.isArray(componentValue) && Array.isArray(formValue) ? componentValue.toString() !== formValue.toString() : componentValue !== formValue) // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          });\n          // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]);\n\n      // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n              var isArrayField = stringToArray(name);\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n              return nextValue;\n            });\n          }\n        };\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      );\n\n      // Create validation rules for fields\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined)\n        // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined)\n        // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name)\n        // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n          nextTouched[name] = true;\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          }\n\n          // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n    var useFormField = function useFormField(_ref10) {\n      var errorArg = _ref10.error,\n        infoArg = _ref10.info,\n        name = _ref10.name,\n        required = _ref10.required,\n        disabled = _ref10.disabled,\n        validateArg = _ref10.validate,\n        validateOnArg = _ref10.validateOn;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name];\n      useEffect(function () {\n        setValidateOn(function (prevValues) {\n          var _extends2;\n          if (typeof prevValues === 'string') {\n            var _ref11;\n            return _ref11 = {}, _ref11[name] = validateOnArg || validateOnProp, _ref11;\n          }\n          return _extends({}, prevValues, (_extends2 = {}, _extends2[name] = validateOnArg || validateOnProp, _extends2));\n        });\n      }, [validateOnArg, name]);\n\n      // Create validation rules for field\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n\n          // priority is given to validateOn prop on formField, if it is\n          // undefined, then we will use the validate prop value of Form.\n          // The reason we don't want to add validateOn = \"submit\" here is\n          // because we don't want to trigger validation of \"submit\" field\n          // when the user is typing in the instant (blur, change)\n          // validation fields.\n          if (validateOnArg && validateOnArg !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnArg;\n          } else if (!validateOnArg && validateOnProp !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnProp;\n          }\n          return function () {\n            delete validationRulesRef.current[name].field;\n            delete validationRulesRef.current[name].validateOn;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n        return undefined;\n      }, [error, name, required, validateArg, disabled, validateOnArg]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOnArg === 'blur' || validateOn[name] === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOnArg === 'change' || validateOn[name] === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput,\n      kind: kind\n    };\n  }, [onChange, kind, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp, validateOnProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: formRef\n  }, rest, {\n    onReset: function onReset(event) {\n      sendAnalytics({\n        type: 'formReset',\n        element: formRef.current,\n        data: event,\n        errors: analyticsRef.current.errors,\n        elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n      });\n      setPendingValidation(undefined);\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n      analyticsRef.current = {\n        start: new Date(),\n        errors: {}\n      };\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      // Prevent any \"outer\" forms from performing `onSubmit`.\n      // Nesting forms is not recommended in HTML. However, with React\n      // portals, if the portal (such as Grommet's Layer) contains a form\n      // and is nested within another form in the React tree, the event\n      // bubbles up to the \"outer\" form even though in the DOM the portal\n      // doesn't render as child of the \"outer\" form.\n      // https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals\n      if (formRef.current && (event.target === formRef.current || event.target.form === formRef.current)) {\n        setPendingValidation(undefined);\n        // adding validateOn: \"submit\" prop to the undefined validateOn\n        // fields as we want to trigger \"submit\" validation once form\n        // is submitted\n        var newValidationRulesRef = Object.keys(validationRulesRef.current).reduce(function (acc, key) {\n          acc[key] = validationRulesRef.current[key];\n          if (!acc[key].validateOn) {\n            acc[key] = _extends({}, validationRulesRef.current[key], {\n              validateOn: 'submit'\n            });\n          }\n          return acc;\n        }, {});\n        var _validateForm2 = validateForm(Object.entries(newValidationRulesRef), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n        setValidationResults(function () {\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            // Show form's validity when clicking on Submit\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          validationResultsRef.current = nextValidationResults;\n          updateAnalytics();\n          return nextValidationResults;\n        });\n        if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n          event.persist(); // extract from React's synthetic event pool\n          var adjustedEvent = event;\n          adjustedEvent.value = value;\n          adjustedEvent.touched = touched;\n          _onSubmit(adjustedEvent);\n          sendAnalytics({\n            type: 'formSubmit',\n            element: formRef.current,\n            data: adjustedEvent,\n            errors: analyticsRef.current.errors,\n            elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n          });\n          analyticsRef.current.errors = {};\n          analyticsRef.current.submitted = true;\n        }\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };","map":{"version":3,"names":["_excluded","_objectWithoutPropertiesLoose","r","e","t","n","hasOwnProperty","call","indexOf","_extends","Object","assign","bind","arguments","length","apply","React","forwardRef","useCallback","useContext","useEffect","useMemo","useRef","useState","useAnalytics","MessageContext","useForwardedRef","FormContext","FormPropTypes","defaultValue","defaultTouched","defaultValidationResults","errors","infos","defaultThreshold","stringToArray","string","match","arrayName","indexOfArray","arrayObjName","undefined","getValueAt","valueObject","pathArg","path","Array","isArray","split","shift","setValueAt","value","object","key","getFieldValue","name","isArrayField","_value$arrayName","obj","setFieldValue","componentValue","prevValue","nextValue","_nextValue$arrayName$","validateCharacterCount","format","rule","max","threshold","getMessage","charactersRemaining","plural","id","values","number","charactersOverLimit","status","message","validate","fieldValue","formValue","messages","result","regexp","test","validateName","validationRules","required","validationResult","some","validateForm","omitValid","nextErrors","nextInfos","forEach","_ref","_ref$","field","input","validateOn","isInstantValidate","includes","Form","_ref2","ref","children","_ref2$errors","errorsProp","_ref2$infos","infosProp","kind","onChange","_onReset","onReset","_onSubmit","onSubmit","onValidate","_ref2$validate","validateOnProp","valueProp","rest","formRef","_useContext","_useState","valueState","setValueState","_useState2","touched","setTouched","_useState3","setValidateOn","_useState4","validationResults","setValidationResults","validationResultsRef","_useState5","mounted","setMounted","_useState6","pendingValidation","setPendingValidation","validationRulesRef","requiredFields","analyticsRef","start","Date","sendAnalytics","buildValid","valid","current","filter","keys","every","filterRemovedFields","prevValidations","nextValidations","updateAnalytics","_validationResultsRef","errorFields","errorCounts","applyValidationRules","_validateForm","validatedErrors","validatedInfos","prevValidationResults","nextValidationResults","entries","_ref3","v","_ref4","_ref5","timer","setTimeout","_ref6","_ref7","clearTimeout","_validationResultsRef2","_ref8","element","type","submitted","elapsed","getTime","formContextValue","useFormInput","_ref9","initialValue","validateArg","_useState7","inputValue","setInputValue","keyCreated","toString","useValue","nextComponentValue","nextTouched","useFormField","_ref10","errorArg","error","infoArg","info","disabled","validateOnArg","prevValues","_extends2","_ref11","index","push","splice","requiredFieldIndex","inForm","onBlur","concat","createElement","event","data","persist","adjustedEvent","preventDefault","target","form","newValidationRulesRef","reduce","acc","_validateForm2","Provider","displayName","propTypes"],"sources":["/home/uranus/portfolio/node_modules/grommet/es6/components/Form/Form.js"],"sourcesContent":["var _excluded = [\"children\", \"errors\", \"infos\", \"messages\", \"kind\", \"onChange\", \"onReset\", \"onSubmit\", \"onValidate\", \"validate\", \"value\"];\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (e.indexOf(n) >= 0) continue; t[n] = r[n]; } return t; }\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nimport React, { forwardRef, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport { useAnalytics } from '../../contexts';\nimport { MessageContext } from '../../contexts/MessageContext';\nimport { useForwardedRef } from '../../utils';\nimport { FormContext } from './FormContext';\nimport { FormPropTypes } from './propTypes';\nvar defaultValue = {};\nvar defaultTouched = {};\nvar defaultValidationResults = {\n  errors: {},\n  infos: {}\n};\nvar defaultThreshold = 0.5;\nvar stringToArray = function stringToArray(string) {\n  var match = string == null ? void 0 : string.match(/^(.+)\\[([0-9]+)\\]\\.(.*)$/);\n  if (match) {\n    var arrayName = match[1],\n      indexOfArray = match[2],\n      arrayObjName = match[3];\n    return {\n      indexOfArray: indexOfArray,\n      arrayName: arrayName,\n      arrayObjName: arrayObjName\n    };\n  }\n  return undefined;\n};\nvar getValueAt = function getValueAt(valueObject, pathArg) {\n  if (valueObject === undefined) return undefined;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) return valueObject[path];\n  return getValueAt(valueObject[path.shift()], path);\n};\nvar setValueAt = function setValueAt(valueObject, pathArg, value) {\n  var object = valueObject;\n  var path = Array.isArray(pathArg) ? pathArg : pathArg.split('.');\n  if (path.length === 1) object[path] = value;else {\n    var key = path.shift();\n    if (!object[key]) object[key] = {};\n    setValueAt(object[key], path, value);\n  }\n};\nvar getFieldValue = function getFieldValue(name, value) {\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var _value$arrayName;\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    var obj = (_value$arrayName = value[arrayName]) == null ? void 0 : _value$arrayName[indexOfArray];\n    return arrayObjName ? obj == null ? void 0 : obj[arrayObjName] : obj;\n  }\n  return getValueAt(value, name);\n};\nvar setFieldValue = function setFieldValue(name, componentValue, prevValue) {\n  var nextValue = _extends({}, prevValue);\n  var isArrayField = stringToArray(name);\n  if (isArrayField) {\n    var indexOfArray = isArrayField.indexOfArray,\n      arrayName = isArrayField.arrayName,\n      arrayObjName = isArrayField.arrayObjName;\n    if (!nextValue[arrayName]) nextValue[arrayName] = [];\n    if (arrayObjName) {\n      var _nextValue$arrayName$;\n      if (!nextValue[arrayName][indexOfArray]) nextValue[arrayName][indexOfArray] = (_nextValue$arrayName$ = {}, _nextValue$arrayName$[arrayObjName] = componentValue, _nextValue$arrayName$);\n      nextValue[arrayName][indexOfArray][arrayObjName] = componentValue;\n    } else nextValue[arrayName][indexOfArray] = componentValue;\n  } else {\n    setValueAt(nextValue, name, componentValue);\n  }\n  return nextValue;\n};\nvar validateCharacterCount = function validateCharacterCount(format, rule, value) {\n  var max = rule.max,\n    threshold = rule.threshold;\n  var getMessage = function getMessage() {\n    var charactersRemaining = function charactersRemaining(plural) {\n      return {\n        id: \"formField.maxCharacters.remaining.\" + (plural ? 'plural' : 'singular'),\n        values: {\n          number: max - value.length\n        }\n      };\n    };\n    var charactersOverLimit = function charactersOverLimit(plural) {\n      return {\n        id: \"formField.maxCharacters.overLimit.\" + (plural ? 'plural' : 'singular'),\n        values: {\n          number: value.length - max\n        }\n      };\n    };\n    if (max - value.length >= 0) {\n      return format(charactersRemaining(max - value.length > 1));\n    }\n    return format(charactersOverLimit(value.length - max > 1));\n  };\n  return value.length / max > (threshold != null ? threshold : defaultThreshold) ? {\n    status: max - value.length >= 0 ? 'info' : 'error',\n    message: getMessage()\n  } : undefined;\n};\n\n// Apply validation rule to field value and send correct messaging.\nvar validate = function validate(rule, fieldValue, formValue, format, messages) {\n  var result;\n  if (typeof rule === 'function') {\n    result = rule(fieldValue, formValue);\n  } else if (rule.regexp) {\n    if (!rule.regexp.test(fieldValue)) {\n      result = rule.message || format({\n        id: 'form.invalid',\n        messages: messages\n      });\n      if (rule.status) {\n        result = {\n          message: result,\n          status: rule.status\n        };\n      }\n    }\n  } else if (rule.max) {\n    result = validateCharacterCount(format, rule, fieldValue);\n  }\n  return result;\n};\n\n// Validates particular key in formValue\nvar validateName = function validateName(validationRules, required) {\n  return function (name, formValue, format, messages) {\n    var fieldValue = getFieldValue(name, formValue);\n    var validationResult;\n    if (required && (\n    // false is for CheckBox\n    fieldValue === undefined || fieldValue === '' || fieldValue === false || Array.isArray(fieldValue) && !fieldValue.length)) {\n      validationResult = format({\n        id: 'form.required',\n        messages: messages\n      });\n    } else if (validationRules) {\n      if (Array.isArray(validationRules)) {\n        validationRules.some(function (rule) {\n          validationResult = validate(rule, fieldValue, formValue, format, messages);\n          return !!validationResult;\n        });\n      } else {\n        validationResult = validate(validationRules, fieldValue, formValue, format, messages);\n      }\n    }\n    return validationResult;\n  };\n};\n\n// Validates all keys in formValue\nvar validateForm = function validateForm(validationRules, formValue, format, messages, omitValid) {\n  var nextErrors = {};\n  var nextInfos = {};\n  validationRules.forEach(function (_ref) {\n    var name = _ref[0],\n      _ref$ = _ref[1],\n      field = _ref$.field,\n      input = _ref$.input,\n      validateOn = _ref$.validateOn;\n    if (!omitValid) {\n      nextErrors[name] = undefined;\n      nextInfos[name] = undefined;\n    }\n    if (!validateOn) return;\n    var result;\n    if (input) {\n      // input() a validation function supplied through useFormInput()\n      result = input(name, formValue, format, messages);\n    }\n    if (field && !result) {\n      // field() a validation function supplied through useFormField()\n      result = field(name, formValue, format, messages);\n    }\n    // typeof error === 'object' is implied for both cases of error with\n    // a status message and for an error object that is a react node\n    if (typeof result === 'object') {\n      if (result.status === 'info') {\n        nextInfos[name] = result.message;\n      } else {\n        nextErrors[name] = result.message || result; // could be a node\n      }\n    } else if (typeof result === 'string') {\n      nextErrors[name] = result;\n    }\n  });\n  return [nextErrors, nextInfos];\n};\nvar isInstantValidate = function isInstantValidate(validateOn) {\n  return ['blur', 'change'].includes(validateOn);\n};\nvar Form = /*#__PURE__*/forwardRef(function (_ref2, ref) {\n  var children = _ref2.children,\n    _ref2$errors = _ref2.errors,\n    errorsProp = _ref2$errors === void 0 ? defaultValidationResults.errors : _ref2$errors,\n    _ref2$infos = _ref2.infos,\n    infosProp = _ref2$infos === void 0 ? defaultValidationResults.infos : _ref2$infos,\n    messages = _ref2.messages,\n    kind = _ref2.kind,\n    onChange = _ref2.onChange,\n    _onReset = _ref2.onReset,\n    _onSubmit = _ref2.onSubmit,\n    onValidate = _ref2.onValidate,\n    _ref2$validate = _ref2.validate,\n    validateOnProp = _ref2$validate === void 0 ? 'submit' : _ref2$validate,\n    valueProp = _ref2.value,\n    rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n  var formRef = useForwardedRef(ref);\n  var _useContext = useContext(MessageContext),\n    format = _useContext.format;\n  var _useState = useState(valueProp || defaultValue),\n    valueState = _useState[0],\n    setValueState = _useState[1];\n  var value = useMemo(function () {\n    return valueProp || valueState;\n  }, [valueProp, valueState]);\n  var _useState2 = useState(defaultTouched),\n    touched = _useState2[0],\n    setTouched = _useState2[1];\n  var _useState3 = useState(validateOnProp),\n    validateOn = _useState3[0],\n    setValidateOn = _useState3[1];\n  var _useState4 = useState({\n      errors: errorsProp,\n      infos: infosProp\n    }),\n    validationResults = _useState4[0],\n    setValidationResults = _useState4[1];\n  // maintain a copy of validationResults in a ref for useEffects\n  // which can't depend on validationResults directly without\n  // causing infinite renders.\n  var validationResultsRef = useRef({});\n  // Simulated onMount state. Consider Form to be mounted once it has\n  // accounted for values originating from controlled inputs (available\n  // at second rendering).\n  var _useState5 = useState('unmounted'),\n    mounted = _useState5[0],\n    setMounted = _useState5[1];\n  useEffect(function () {\n    if (!mounted) setMounted('mounting');else if (mounted === 'mounting') setMounted('mounted');\n  }, [mounted]);\n  // `pendingValidation` is the name of the FormField awaiting validation.\n  var _useState6 = useState(undefined),\n    pendingValidation = _useState6[0],\n    setPendingValidation = _useState6[1];\n  var validationRulesRef = useRef({});\n  var requiredFields = useRef([]);\n  var analyticsRef = useRef({\n    start: new Date(),\n    errors: {}\n  });\n  var sendAnalytics = useAnalytics();\n  var buildValid = useCallback(function (nextErrors) {\n    var valid = false;\n    valid = requiredFields.current.filter(function (n) {\n      return Object.keys(validationRulesRef.current).includes(n);\n    }).every(function (field) {\n      return value[field] && (value[field] !== '' || value[field] !== false);\n    });\n    if (Object.keys(nextErrors).length > 0) valid = false;\n    return valid;\n  }, [value]);\n\n  // Only keep validation results for current form fields. In the case of a\n  // dynamic form, a field possessing an error may have been removed from the\n  // form; need to clean up any previous related validation results.\n  var filterRemovedFields = function filterRemovedFields(prevValidations) {\n    var nextValidations = prevValidations;\n    return Object.keys(nextValidations).filter(function (n) {\n      return !validationRulesRef.current[n] || nextValidations[n] === undefined;\n    }).forEach(function (n) {\n      return delete nextValidations[n];\n    });\n  };\n  var updateAnalytics = function updateAnalytics() {\n    var _validationResultsRef;\n    var errorFields = Object.keys((_validationResultsRef = validationResultsRef.current) == null ? void 0 : _validationResultsRef.errors);\n    var errorCounts = analyticsRef.current.errors;\n    if (errorFields.length > 0) {\n      errorFields.forEach(function (key) {\n        errorCounts[key] = (errorCounts[key] || 0) + 1;\n      });\n    }\n  };\n  var applyValidationRules = useCallback(function (validationRules) {\n    var _validateForm = validateForm(validationRules, value, format, messages),\n      validatedErrors = _validateForm[0],\n      validatedInfos = _validateForm[1];\n    setValidationResults(function (prevValidationResults) {\n      // Keep any previous errors and infos for untouched keys,\n      // these may have come from a Submit.\n      var nextErrors = _extends({}, prevValidationResults.errors, validatedErrors);\n      var nextInfos = _extends({}, prevValidationResults.infos, validatedInfos);\n      // Remove previous errors and infos for keys no longer in the\n      // form, these may have been fields removed from a dynamic form.\n      filterRemovedFields(nextErrors);\n      filterRemovedFields(nextInfos);\n      var nextValidationResults = {\n        errors: nextErrors,\n        infos: nextInfos\n      };\n      if (onValidate) onValidate(_extends({}, nextValidationResults, {\n        valid: buildValid(nextErrors)\n      }));\n      validationResultsRef.current = nextValidationResults;\n      updateAnalytics();\n      return nextValidationResults;\n    });\n  }, [buildValid, format, messages, onValidate, value]);\n\n  // Validate all fields holding values onMount if set to\n  // validate when blur or change.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    // Use simulated onMount state to account for values provided by\n    // controlled inputs.\n    if (mounted !== 'mounted' && (isInstantValidate(validateOn) || validationRules.some(function (_ref3) {\n      var v = _ref3[1];\n      return isInstantValidate(v.validateOn);\n    })) && Object.keys(value).length > 0 && Object.keys(touched).length === 0) {\n      applyValidationRules(validationRules.filter(function (_ref4) {\n        var n = _ref4[0],\n          v = _ref4[1];\n        return getFieldValue(n, value) && v.validateOn;\n      })\n      // Exlude empty arrays which may be initial values in\n      // an input such as DateInput.\n      .filter(function (_ref5) {\n        var n = _ref5[0];\n        return !(Array.isArray(getFieldValue(n, value)) && getFieldValue(n, value).length === 0);\n      }));\n    }\n  }, [applyValidationRules, mounted, touched, validateOn, value]);\n\n  // Run validation against fields with pendingValidations from onBlur\n  // and/or onChange.\n  useEffect(function () {\n    var validationRules = Object.entries(validationRulesRef.current);\n    var timer = setTimeout(function () {\n      if (pendingValidation && (isInstantValidate(validateOn) || validationRules.some(function (_ref6) {\n        var v = _ref6[1];\n        return isInstantValidate(v.validateOn);\n      }))) {\n        applyValidationRules(validationRules.filter(function (_ref7) {\n          var n = _ref7[0],\n            v = _ref7[1];\n          return (touched[n] || pendingValidation.includes(n)) && v.validateOn;\n        }));\n        setPendingValidation(undefined);\n      }\n      // Complete any potential click events before running onBlur validation.\n      // Otherwise, click events like reset, etc. may not be registered. For a\n      // detailed scenario/discussion, see: https://github.com/grommet/grommet/issues/4863\n      // Values empirically tested; 120 was selected because it is the largest\n      // Chrome: 100, Safari: 120, Firefox: 80\n    }, 120);\n    return function () {\n      return clearTimeout(timer);\n    };\n  }, [applyValidationRules, pendingValidation, touched, validateOn]);\n\n  // Re-run validation rules for all fields with prior errors.\n  // if validate=blur this helps re-validate if there are errors\n  // as the user fixes them (basically act like validate=change for that)\n  useEffect(function () {\n    var _validationResultsRef2;\n    var validationRules = Object.entries(validationRulesRef.current);\n    if ((_validationResultsRef2 = validationResultsRef.current) != null && _validationResultsRef2.errors && Object.keys(validationResultsRef.current.errors).length > 0) {\n      applyValidationRules(validationRules.filter(function (_ref8) {\n        var n = _ref8[0];\n        return touched[n] && validationResultsRef.current.errors[n];\n      }));\n    }\n  }, [applyValidationRules, touched]);\n  useEffect(function () {\n    var element = formRef.current;\n    analyticsRef.current = {\n      start: new Date(),\n      errors: {}\n    };\n    sendAnalytics({\n      type: 'formOpen',\n      element: element\n    });\n    return function () {\n      if (!analyticsRef.current.submitted) {\n        sendAnalytics({\n          type: 'formClose',\n          element: element,\n          errors: analyticsRef.current.errors,\n          elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n        });\n      }\n    };\n  }, [sendAnalytics, formRef]);\n\n  // There are three basic patterns of handling form input value state:\n  //\n  // 1 - form controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the Form component to supply the values used by the input fields.\n  // In useFormContext(), componentValue would be undefined and formValue\n  // is be set to whatever the form state has. Whenever the form state\n  // changes, we update the contextValue so the input component will use\n  // that. When the input component changes, we will call update() to\n  // update the form state.\n  //\n  // 2 - input controlled\n  //\n  // In this model, the caller sets `value` and `onChange` properties\n  // on the input components, like TextInput, to supply the value for it.\n  // In useFormContext(), componentValue is this value and we ensure to\n  // update the form state, via update(), and set the contextValue from\n  // the componentValue. When the input component changes, we will\n  // call update() to update the form state.\n  //\n  // 3 - uncontrolled\n  //\n  // In this model, the caller doesn't set a `value` or `onChange` property\n  // at either the form or input component levels.\n  // In useFormContext(), componentValue is undefined and valueProp is\n  // undefined and nothing much happens here. That is, unless the\n  // calling component needs to know the state in order to work, such\n  // as CheckBox or Select. In this case, those components supply\n  // an initialValue, which will trigger updating the contextValue so\n  // they can have access to it.\n  //\n  var formContextValue = useMemo(function () {\n    var useFormInput = function useFormInput(_ref9) {\n      var name = _ref9.name,\n        componentValue = _ref9.value,\n        initialValue = _ref9.initialValue,\n        validateArg = _ref9.validate;\n      var _useState7 = useState(initialValue),\n        inputValue = _useState7[0],\n        setInputValue = _useState7[1];\n      var formValue = name ? getFieldValue(name, value) : undefined;\n      // for dynamic forms, we need to track when an input has been added to\n      // the form value. if the input is unmounted, we will delete its\n      // key/value from the form value.\n      var keyCreated = useRef(false);\n\n      // This effect is for pattern #2, where the controlled input\n      // component is driving the value via componentValue.\n      useEffect(function () {\n        if (name &&\n        // we have somewhere to put this\n        componentValue !== undefined && (\n        // input driving\n        Array.isArray(componentValue) && Array.isArray(formValue) ? componentValue.toString() !== formValue.toString() : componentValue !== formValue) // don't already have it\n        ) {\n          setValueState(function (prevValue) {\n            return setFieldValue(name, componentValue, prevValue);\n          });\n          // don't onChange on programmatic changes\n        }\n      }, [componentValue, formValue, name]);\n\n      // on unmount, if the form is uncontrolled, remove the key/value\n      // from the form value\n      useEffect(function () {\n        return function () {\n          if (keyCreated.current) {\n            keyCreated.current = false;\n            setValueState(function (prevValue) {\n              var nextValue = _extends({}, prevValue);\n              var isArrayField = stringToArray(name);\n              if (isArrayField) {\n                var arrayName = isArrayField.arrayName;\n                delete nextValue[arrayName];\n              } else {\n                delete nextValue[name];\n              }\n              return nextValue;\n            });\n          }\n        };\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [] // only run onmount and unmount\n      );\n\n      // Create validation rules for fields\n      useEffect(function () {\n        if (validateArg) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].input = validateName(validateArg);\n          return function () {\n            return delete validationRulesRef.current[name].input;\n          };\n        }\n        return undefined;\n      }, [validateArg, name]);\n      var useValue;\n      if (componentValue !== undefined)\n        // input component drives, pattern #2\n        useValue = componentValue;else if (valueProp && name && formValue !== undefined)\n        // form drives, pattern #1\n        useValue = formValue;else if (formValue === undefined && name)\n        // form has reset, so reset input value as well\n        useValue = initialValue;else useValue = inputValue;\n      return [useValue, function (nextComponentValue) {\n        if (name) {\n          // we have somewhere to put this\n          var nextTouched = _extends({}, touched);\n          nextTouched[name] = true;\n          if (!touched[name]) {\n            // don't update if not needed\n            setTouched(nextTouched);\n          }\n\n          // if nextValue doesn't have a key for name, this must be\n          // uncontrolled form. we will flag this field was added so\n          // we know to remove its value from the form if it is dynamically\n          // removed\n          if (!(name in value)) keyCreated.current = true;\n          var nextValue = setFieldValue(name, nextComponentValue, value);\n          setValueState(nextValue);\n          if (onChange) onChange(nextValue, {\n            touched: nextTouched\n          });\n        }\n        if (initialValue !== undefined) setInputValue(nextComponentValue);\n      }];\n    };\n    var useFormField = function useFormField(_ref10) {\n      var errorArg = _ref10.error,\n        infoArg = _ref10.info,\n        name = _ref10.name,\n        required = _ref10.required,\n        disabled = _ref10.disabled,\n        validateArg = _ref10.validate,\n        validateOnArg = _ref10.validateOn;\n      var error = disabled ? undefined : errorArg || validationResults.errors[name];\n      var info = infoArg || validationResults.infos[name];\n      useEffect(function () {\n        setValidateOn(function (prevValues) {\n          var _extends2;\n          if (typeof prevValues === 'string') {\n            var _ref11;\n            return _ref11 = {}, _ref11[name] = validateOnArg || validateOnProp, _ref11;\n          }\n          return _extends({}, prevValues, (_extends2 = {}, _extends2[name] = validateOnArg || validateOnProp, _extends2));\n        });\n      }, [validateOnArg, name]);\n\n      // Create validation rules for field\n      useEffect(function () {\n        var index = requiredFields.current.indexOf(name);\n        if (required) {\n          if (index === -1) requiredFields.current.push(name);\n        } else if (index !== -1) requiredFields.current.splice(index, 1);\n        if (validateArg || required) {\n          if (!validationRulesRef.current[name]) {\n            validationRulesRef.current[name] = {};\n          }\n          validationRulesRef.current[name].field = validateName(validateArg, required);\n\n          // priority is given to validateOn prop on formField, if it is\n          // undefined, then we will use the validate prop value of Form.\n          // The reason we don't want to add validateOn = \"submit\" here is\n          // because we don't want to trigger validation of \"submit\" field\n          // when the user is typing in the instant (blur, change)\n          // validation fields.\n          if (validateOnArg && validateOnArg !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnArg;\n          } else if (!validateOnArg && validateOnProp !== 'submit') {\n            validationRulesRef.current[name].validateOn = validateOnProp;\n          }\n          return function () {\n            delete validationRulesRef.current[name].field;\n            delete validationRulesRef.current[name].validateOn;\n            var requiredFieldIndex = requiredFields.current.indexOf(name);\n            if (requiredFieldIndex !== -1) {\n              requiredFields.current.splice(requiredFieldIndex, 1);\n            }\n          };\n        }\n        return undefined;\n      }, [error, name, required, validateArg, disabled, validateOnArg]);\n      return {\n        error: error,\n        info: info,\n        inForm: true,\n        onBlur: validateOnArg === 'blur' || validateOn[name] === 'blur' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined,\n        onChange: validateOnArg === 'change' || validateOn[name] === 'change' ? function () {\n          return setPendingValidation(pendingValidation ? [].concat(pendingValidation, [name]) : [name]);\n        } : undefined\n      };\n    };\n    return {\n      useFormField: useFormField,\n      useFormInput: useFormInput,\n      kind: kind\n    };\n  }, [onChange, kind, pendingValidation, touched, validateOn, validationResults.errors, validationResults.infos, value, valueProp, validateOnProp]);\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: formRef\n  }, rest, {\n    onReset: function onReset(event) {\n      sendAnalytics({\n        type: 'formReset',\n        element: formRef.current,\n        data: event,\n        errors: analyticsRef.current.errors,\n        elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n      });\n      setPendingValidation(undefined);\n      if (!valueProp) {\n        setValueState(defaultValue);\n        if (onChange) onChange(defaultValue, {\n          touched: defaultTouched\n        });\n      }\n      setTouched(defaultTouched);\n      setValidationResults(defaultValidationResults);\n      analyticsRef.current = {\n        start: new Date(),\n        errors: {}\n      };\n      if (_onReset) {\n        event.persist(); // extract from React's synthetic event pool\n        var adjustedEvent = event;\n        adjustedEvent.value = defaultValue;\n        _onReset(adjustedEvent);\n      }\n    },\n    onSubmit: function onSubmit(event) {\n      // Don't submit the form via browser form action. We don't want it\n      // if the validation fails. And, we assume a javascript action handler\n      // otherwise.\n      event.preventDefault();\n      // Prevent any \"outer\" forms from performing `onSubmit`.\n      // Nesting forms is not recommended in HTML. However, with React\n      // portals, if the portal (such as Grommet's Layer) contains a form\n      // and is nested within another form in the React tree, the event\n      // bubbles up to the \"outer\" form even though in the DOM the portal\n      // doesn't render as child of the \"outer\" form.\n      // https://legacy.reactjs.org/docs/portals.html#event-bubbling-through-portals\n      if (formRef.current && (event.target === formRef.current || event.target.form === formRef.current)) {\n        setPendingValidation(undefined);\n        // adding validateOn: \"submit\" prop to the undefined validateOn\n        // fields as we want to trigger \"submit\" validation once form\n        // is submitted\n        var newValidationRulesRef = Object.keys(validationRulesRef.current).reduce(function (acc, key) {\n          acc[key] = validationRulesRef.current[key];\n          if (!acc[key].validateOn) {\n            acc[key] = _extends({}, validationRulesRef.current[key], {\n              validateOn: 'submit'\n            });\n          }\n          return acc;\n        }, {});\n        var _validateForm2 = validateForm(Object.entries(newValidationRulesRef), value, format, messages, true),\n          nextErrors = _validateForm2[0],\n          nextInfos = _validateForm2[1];\n        setValidationResults(function () {\n          var nextValidationResults = {\n            errors: nextErrors,\n            infos: nextInfos,\n            // Show form's validity when clicking on Submit\n            valid: buildValid(nextErrors)\n          };\n          if (onValidate) onValidate(nextValidationResults);\n          validationResultsRef.current = nextValidationResults;\n          updateAnalytics();\n          return nextValidationResults;\n        });\n        if (Object.keys(nextErrors).length === 0 && _onSubmit) {\n          event.persist(); // extract from React's synthetic event pool\n          var adjustedEvent = event;\n          adjustedEvent.value = value;\n          adjustedEvent.touched = touched;\n          _onSubmit(adjustedEvent);\n          sendAnalytics({\n            type: 'formSubmit',\n            element: formRef.current,\n            data: adjustedEvent,\n            errors: analyticsRef.current.errors,\n            elapsed: new Date().getTime() - analyticsRef.current.start.getTime()\n          });\n          analyticsRef.current.errors = {};\n          analyticsRef.current.submitted = true;\n        }\n      }\n    }\n  }), /*#__PURE__*/React.createElement(FormContext.Provider, {\n    value: formContextValue\n  }, children));\n});\nForm.displayName = 'Form';\nForm.propTypes = FormPropTypes;\nexport { Form };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}